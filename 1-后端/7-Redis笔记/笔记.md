# Redis 启停

- 宝塔
- ps aux | grep 和 kill -9

# 异常处理

- NOAUTH Authentication required.

  去配置文件搜requirepass 密码

  然后需要auth命令或者设置密码

- 阿里云端口， 防火墙都要放行端口

# 配置允许远程连接

```
# 允许任何主机连接、访问
bind 127.0.0.1 改为 bind 0.0.0.0
 
# 关闭保护模式
protected-mode yes 改为 protected-mode no
 
# 允许启动后在后台运行，即关闭命令行窗口后仍能运行
daemonize no 改为 daemonize yes
```

# windows命令行远程连接

```bash
redis-cli -h 120.79.139.31
auth [password]
```

# 切换/查看数据库指令

```bash
//切换数据库
select [0,1,2...]
//查看数据库
第一个数据库是不会显示的 120.79.139.31:6379>
其他的会显示为 120.79.139.31:6379[1]>
```

# 控制台消息清除

```bash
clear
```



# Redis命令

```bash
set key value
get key
move key db
del key
keys *
expire key seconds
ttl key
flushall
flushdb //清除当前数据库的数据
exists key
type key
```

## 字符串

```bash
append key value
strlen key
-- 自增
incr key
decr key
incrby key 10
decrby key 10
-- 截取字符串
getrange key start end
setrange key offset value
-- setex 设置键过期时间，setnx 如果不存在就设置
setex key seconds value
setnx key value
-- 批量设置
mset k1 v1 k2 v2 ...
-- :
set user:1:name root 
-- 获取旧值然后设置新值
getset key value
```

## List

使用场景：可以作为栈，队列，阻塞队列（出口入口相同 则为栈  出口入口不同 则为队列）

```bash
所有的list命令都以l开头或者r开头
end可以是-1, 表示最后一个
lpush表示从左边给list添加元素
lrange表示从左边开始遍历list

lpush list 1
lrange key start end

lpop list
rpop list
//通过下标获取值
lindex list 0
//获取list的长度
llen list
//移除n个指定的元素
lrem list n one
//截取下标1开始,终点下标为2作为新的list(改变了原来的list)
ltrim list 1 2

//移除列表最后一个元素添加到另一个数组种
rpoplpush mylist myotherlist 

//设置list第0索引为item(理解成更新操作,如果list和下标不存在都会报错)
lset list 0 item

//
linsert list before "world" "other"
```

## Set

```bash
//给set添加元素
sadd set ""
//查看set的所有成员
smembers set
//是否在set中存在world
sismember set world
//获取长度
scard set
//移除set中的hello元素
srem set hello
//随机抽出一个元素
srandmember set
//随机移除一个元素
spop set
//移动hello元素,从myset到otherset
smove myset otherset hello
//差集找出不同的
sdiff key1 key2
//交集
sinter key1 key2
//并集
sunion key1 key2 
```

## Hash

>hset myhash key重复的话 后面写的会覆盖前面写的val

```bash
//添加一个键值对
hset myhash field1 kuangshen
//获取值
hget myhash field1
//同时多个键值对
hmset myhash field1 hello field2 world
//同时取多个键值对
hmget myhash field1 field2
//获取所有的键值对
hgetall myhash
//删除
hdel myhash field1
//获取hash的长度
hlen
//判断某个字段是否存在
hexists myhash field1
//只获得所有的key
hkeys myhash
//只获得所有的value
hvals myhash
//value是数字时, 给他自增多少
hincrby myhash field1 5
//不存在则创建
hsetnx myhash field1 hello
```

## Zset

```bash
//添加一个/多个zset元素, 数组是用于排序的标记
zadd myset 1 one
zadd myset 2 two 3 three
//排序从小到大
zrangebyscore myset -inf +inf
//倒序从大到小
zrevrange myset 0 -1
//遍历部分的zset/切片
zrange salary 0 -1
//获取有序集合中的个数
zcard salary
//获取指定区间的成员数量
zcount myset 1 3
```

## Geospatial

```
用于计算地理空间
当你给定好两个点的经纬度，redis可以算出这两点的距离
```

## Hyperloglog

```
用于计算基数！
比如网页的UV(一个人访问一个网站多次,但是还是算作一个人)
```

## Bitmaps

```
用于统计用户信息，活跃，不活跃，登录，未登录，打卡，365打卡两个状态的都可以用bitmaps
位图数据结构，操作二进制位来进行记录，只有0和1两个状态
```

# Redis事务

redis事务本质：一组命令的集合！一个事务中所有的命令都会被序列化，在事务执行过程中，会按照顺序执行



- redis单条命令是保证原子性的，事务不保证原子性

- Redis事务没有隔离级别的概念

- 所有的命令在事务中，并没有立马执行，只要发起执行命令才会执行



事务步骤

1. 开启事务
2. 命令入队
3. 执行事务

事务命令

multi

exec

discard

# Redis乐观锁

悲观锁：做什么都会加锁

乐观锁：

- 认为什么时候都不会出问题，所以不会上锁，更新数据的时候取判断一下，再次期间是否有人修改过这个数据 version
- 获取version
- 更新时比较version

监视命令 watch unwatch

```
watch money 
multi
decrby money 10
incrby out 10
exec # 执行之前，如果有另一个线程取修改了money，watch比较version失败，事务会自动取消/执行失败
```

如果事务的命令失败, unwatch一下, 再重新watch一下



# Jedis

导入

```
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>3.0.1</version>
</dependency>
```

使用

```
public static void main(String[] args) {
        //连接redis
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        System.out.println(jedis.ping());
        //Jedis所有的方法都是之前的redis命令！！！

        //验证密码
        jedis.auth("");
        //开启事务
        Transaction multi = jedis.multi();
        jedis.watch("");
        multi.exec();
    }
```



# springboot整合 自定义RedisTemplate

1. 导入

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

说明在springboot2.x之后, 原来使用jedis被替换为了lettuce

jedis: 采用直连, 多个线程操作的话,是不安全的, 如果要避免不安全,使用jedispool连接池 BIO

lettuce: 采用netty, 实例可以在多个线程中进行共享, 不存在线程不安全的情况

2. 书写配置

```
//1.Springboot 所有的配置类，都有一个自动配置类，RedisAutoConfiguration
//自动配置类都会绑定一个properties配置文件 RedisProperties
//2.@ConditionOnMissingBean(name="redisTemplate")
//如果没有这个名字的实例, 则会创建springboot默认的redistemplate对象
//3.配置redis
spring.redis.host=127.0.0.1
spring.redis.port=6379
```

3. 操作redis

```
@Resource
private RedisTemplate redisTemplate

test(){
	//opsForList
	//opsForSet
	//opsForHash
	//opsForZset
	//opsForGeo
	//opsForHyperLoglog
	redisTemplate.opsForValue()
	
}
```

4. 序列化配置 (编写自己的RedisTemplate)

```
//为什么要序列化: 当你需要通过媒介(网络)传输对象时, 对象不能直接传输, 需要序列化
//什么是序列化:
当你的pojo类去实现Serializable接口时, 当你去传输pojo对象时, 会把他进行序列化操作
//序列化操作有默认的jdk的序列化, 有json的序列化(开发一般使用json的序列化)
我们需要指定序列化方式
//小细节, 如果是jdk的序列化方式, keys * 在命令行是会有转义字符的!
```

自己定义的RedisTemplate

```java
@Bean
    public RedisTemplate<String, Object > myRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory);
        //序列化配置
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        //String 的序列化方式
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        //key 采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        //hash的key 采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        //value 采用jackon的序列化方式
        template.setValueSerializer(jackson2JsonRedisSerializer);
        //hash的value 采用jackon的序列化方式
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        return template;
    }
```

# Redis.conf配置详解

- 网络

  ```
  //服务器的redis, 主要改这三个公网ip, 不保护, 改端口
  bind 0.0.0.0 # 是绑定到本机的所有IP上
  protected-mode yes # 一般不保护
  port 6379
  ```

- 通用

  ```conf
  daemonize yes # 以守护进程的方式进行, 默认是no. 不yes的话, 一退出redis就关掉啦
  pidfile # 如果以后台的方式运行，需要指定一个进程文件
  loglevel notice
  logfile "" # 日志文件的位置
  databases 16 # 数据库的数量,默认16个
  always-show-logo yes # 启动是否显示logo
  ```

- 快照( ==持久化==用到的, 在规定时间内, 执行了多少次操作, 则会持久化到文件 )

  redis是内存数据库, 如果没有持久化, 那么数据断电就没

  ```
  save 900 1 # 如果900秒内, 如果至少有 1个key进行了修改, 我们即使进行持久化操作
  dir ./ # rdb文件保存的目录
  dbfilename dump.rdb # rdb文件名
  stop-writes-on-bgsave-error yes # 持久化出错是否继续工作
  rdbcompression yes # 是否压缩rdb文件,需要消耗一些cpu资源
  rdbchecksum yes # 保存rdb文件的时候, 进行错误的检查校验
  ```

- REPLICATION 主从复制相关的

  ```
  info replication # redis连接环境命令
  replicaof host port # 连接主机，自己作为从机
  masterauth # 主机连接redis密码
  ```

- SECURITY

  ```
  requirepass 
  # 通过命令设置
  config set requirepass ""
  # 通过命令,使用密码, 才能使用命令
  auth [password]
  ```

- CLIENTS

  ```
  maxclients 1000 # 设置能连接上redis的最大客户端的数量
  maxmemory <bytes> # 设置最大的内存容量
  maxmemory-policy noeviction # 内存到达上限之后的处理策略
  1、volatile-lru: 只对设置了过期时间的key进行LRU(默认值)
  2、allkeys-lru : 删除lru算法的key
  3、volatile-random: 随机删除即将过期key
  4、allkeys-random: 随机删除
  5、volatile-ttl : 删除即将过期的
  6、noeviction : 永不过期，返回错误
  ```

- APPEND ONLY

  ```
  appendonly no # 默认是不开启aof模式的, 默认使用rdb方式持久化,在大部分情况下rdb够用了
  appendfilename "appendonly" # aof文件名
  appendsync everysec # everysec每秒执行一次同步| always每次修改就同步 | no操作系统自己同步数据,速度最快
  配置了no-appendfsync-on-rewrite则使得在持久化过程中的操作不会被记录，提高主进程的性能（但是开了不安全）
  auto-aof-rewrite-percentage 100 #
  auto-aof-rewrite-min-size 64mb #如果aof大于64mb，fork新进程来重写文件
  ```
  
  

# Redis持久化

## RDB

>难理解的是因为没搞懂持久化的概念，所谓持久化就是讲二进制写入文件，所以写入临时文件和写入正式RDB文件都是持久化，这样就理解了
>
>默认配置已经基本够用的

- 什么时候redis会持久化生成rdb
  1. save规则满足
  2. 执行flushall命令
  3. 关机redis

- 如何恢复rdb到内存中

  1. 只需要rdb文件放在redis启动目录就可以，在当前目录下启动redis, 会自动检查dump.rdb恢复其中的数据

  2. ```
     在连接reids状态下
     config get dir #得到的就是redis启动目录
     ```

- 优点
  1. 适合大规模的数据恢复
  2. 对数据的完整性要求不高
- 缺点
  1. 需要一定时间间隔进程操作,如果当中宕机,最后一次时间间隔的数据就丢失了
  2. fork进程的时候会占用一定的内存空间

## AOF( Append Only File)

>和mysql的备份类似, 记录所有写的操作

- 什么时候触发AOF的持久化?
  1. 根据你的配置规则
- 什么时候恢复?
  1. 当你启动redis的时候会自动读取aof文件,自动恢复数据
- 存在被破坏的可能, redis提供有aof修复工具
- 优点
  1. 每一次修改都同步, 文件的完整会更好
  2. 每秒同步一次, 最坏也就会丢失一秒的数据
  3. 从不同步,效率最高
- 缺点
  1. 相对于数据文件来说, aof远远大于rdb, 恢复速度页慢于rdb
  2. aof运行效率也慢于rdb, 所有默认不开启aof

## 两者一起使用



# Redis发布订阅

发布者 频道 订阅者

- publish channel message
- subscribe channel
- unsubscribe channel



使用场景

1. 实时消息系统
2. 事实聊天
3. 订阅, 关注



# Redis主从复制

![image-20240406210943041](./笔记/image-20240406210943041.png)

主机写, 从机读; 顺序只能这样

- 一台主机上模拟集群
  1. 端口
  2. pid文件
  3. 日志文件名字
  4. rdb文件名字

## 一主二从

默认情况下redis都是主机, 只需要把某些redis变从机即可

- 如何让redis去切换从机身份

  - ```
    slaveof host port #这是命令的
    ```

- 主机有密码的小伙伴，在从机的配置文件conf里加上：masterauth 密码

- 只有主机才可以写入, 从机写入会报错; 主机写入了数据, 从机可以读到



- 如果主机断了, 从机会怎么样吗?
  - 会保持连接,等待主机上限 => 没有写的操作了; 这是主机如果回来了, 从机又可以进行读到新写入的数据
- 从机断了, 在重新连接主机, 数据任然和主机同步



同步原理: 

![image-20240406213720185](./笔记/image-20240406213720185.png)



连接模型

1. 一个主机对多台从机
2. 主机=>从机(有是主机又是从机, 但是只能读)=>从机



## 哨兵模式

>其实就是主从复制的升级, 主从复制主机断了,在产生一个主机变得自动了

手动: 如果主机断了, 从机可以通过`slaveof no one`使自己变成主机(哨兵没有出来之前)

1. 配置哨兵配置文件

   sentinel.conf

   ```conf
   sential monitor myredis 127.0.0.1 6379 1 #1是 只要有一个哨兵认为redis宕机了，就开始投票把MAster转给slave
   # 哨兵集群配置， 还至少需要配置端口
   ```

2. 启动哨兵



如果主机回来, 只能归到新的主机下做从机



# Redis缓存穿透和学崩( 工作常用)

缓存穿透: 没查到

​	解决方案

​		布隆过滤器

​		缓存空对象

缓存击穿: 所有人去访问热点数据, 差太多了

​	解决方案: 

​		设置热点数据永不过期

​		分布式锁( setnx ), 一个key同一时间只能1个线程访问

缓存雪崩:  缓存集中过期

​	解决方案:

​		redis高可用( 就是集群)

​		限流降级( 某个key只允许一个线程查询数据和写缓存,其他线程等待)

​		数据预热(在大量访问之前前, 将数据预先访问一遍)

# 关键词

定时删除, 惰性删除, 内存淘汰

布隆过滤器: 缓存穿透, 缓存击穿, 缓存雪崩 (过期时间均匀分布, 热点数据永不过期)

# Springboot中集成Redis

1. 修改application.yml配置文件

2. 配置基本参数 host port password

3. 定义自己的RedisTemplate, @Resource(name = "指定自己的bean名")

4. 使用RedisTemplate





# 使用redis

1. 测试rdb,能不能恢复
2. 搭建伪集群看看效果
   - 搭建伪集群环境
   - 命令式认老大
   - 配置式认老大
   - 当主机挂了, 从机只可以读挂之前的数据, 当主机重新上线后, 主机和从机又可用继续正常工作, 主机新写入的数据式同步的

### window下的redis有两个配置文件，默认使用window-service.conf

