# Redis 启停

- 宝塔
- ps aux | grep 和 kill -9

# 异常处理

- NOAUTH Authentication required.

  去配置文件搜requirepass 密码

  然后需要auth命令或者设置密码

- 阿里云端口， 防火墙都要放行端口

# 配置允许远程连接

```
# 允许任何主机连接、访问
bind 127.0.0.1 改为 bind 0.0.0.0
 
# 关闭保护模式
protected-mode yes 改为 protected-mode no
 
# 允许启动后在后台运行，即关闭命令行窗口后仍能运行
daemonize no 改为 daemonize yes
```

# windows命令行远程连接

```bash
redis-cli -h 120.79.139.31
auth [password]
```

# 切换/查看数据库指令

```bash
//切换数据库
select [0,1,2...]
//查看数据库
第一个数据库是不会显示的 120.79.139.31:6379>
其他的会显示为 120.79.139.31:6379[1]>
```

# 控制台消息清除

```bash
clear
```



# Redis命令

```bash
set key value
get key
move key db
del key
keys *
expire key seconds
ttl key
flushall
flushdb //清除当前数据库的数据
exists key
type key
```

## 字符串

```bash
append key value
strlen key
-- 自增
incr key
decr key
incrby key 10
decrby key 10
-- 截取字符串
getrange key start end
setrange key offset value
-- setex 设置键过期时间，setnx 如果不存在就设置
setex key seconds value
setnx key value
-- 批量设置
mset k1 v1 k2 v2 ...
-- :
set user:1:name root 
-- 获取旧值然后设置新值
getset key value
```

## List

使用场景：可以作为栈，队列，阻塞队列（出口入口相同 则为栈  出口入口不同 则为队列）

```bash
所有的list命令都以l开头或者r开头
end可以是-1, 表示最后一个
lpush表示从左边给list添加元素
lrange表示从左边开始遍历list

lpush list 1
lrange key start end

lpop list
rpop list
//通过下标获取值
lindex list 0
//获取list的长度
llen list
//移除n个指定的元素
lrem list n one
//截取下标1开始,终点下标为2作为新的list(改变了原来的list)
ltrim list 1 2

//移除列表最后一个元素添加到另一个数组种
rpoplpush mylist myotherlist 

//设置list第0索引为item(理解成更新操作,如果list和下标不存在都会报错)
lset list 0 item

//
linsert list before "world" "other"
```

## Set

```bash
//给set添加元素
sadd set ""
//查看set的所有成员
smembers set
//是否在set中存在world
sismember set world
//获取长度
scard set
//移除set中的hello元素
srem set hello
//随机抽出一个元素
srandmember set
//随机移除一个元素
spop set
//移动hello元素,从myset到otherset
smove myset otherset hello
//差集找出不同的
sdiff key1 key2
//交集
sinter key1 key2
//并集
sunion key1 key2 
```

## Hash

>hset myhash key重复的话 后面写的会覆盖前面写的val

```bash
//添加一个键值对
hset myhash field1 kuangshen
//获取值
hget myhash field1
//同时多个键值对
hmset myhash field1 hello field2 world
//同时取多个键值对
hmget myhash field1 field2
//获取所有的键值对
hgetall myhash
//删除
hdel myhash field1
//获取hash的长度
hlen
//判断某个字段是否存在
hexists myhash field1
//只获得所有的key
hkeys myhash
//只获得所有的value
hvals myhash
//value是数字时, 给他自增多少
hincrby myhash field1 5
//不存在则创建
hsetnx myhash field1 hello
```

## Zset

```bash
//添加一个/多个zset元素, 数组是用于排序的标记
zadd myset 1 one
zadd myset 2 two 3 three
//排序从小到大
zrangebyscore myset -inf +inf
//倒序从大到小
zrevrange myset 0 -1
//遍历部分的zset/切片
zrange salary 0 -1
//获取有序集合中的个数
zcard salary
//获取指定区间的成员数量
zcount myset 1 3
```

## Geospatial

```
用于计算地理空间
当你给定好两个点的经纬度，redis可以算出这两点的距离
```

## Hyperloglog

```
用于计算基数！
比如网页的UV(一个人访问一个网站多次,但是还是算作一个人)
```

## Bitmaps

```
用于统计用户信息，活跃，不活跃，登录，未登录，打卡，365打卡两个状态的都可以用bitmaps
位图数据结构，操作二进制位来进行记录，只有0和1两个状态
```

# Redis事务

redis事务本质：一组命令的集合！一个事务中所有的命令都会被序列化，在事务执行过程中，会按照顺序执行



- redis单条命令是保证原子性的，事务不保证原子性

- Redis事务没有隔离级别的概念

- 所有的命令在事务中，并没有立马执行，只要发起执行命令才会执行



事务步骤

1. 开启事务
2. 命令入队
3. 执行事务

事务命令

multi

exec

discard

# Redis乐观锁

悲观锁：做什么都会加锁

乐观锁：

- 认为什么时候都不会出问题，所以不会上锁，更新数据的时候取判断一下，再次期间是否有人修改过这个数据 version
- 获取version
- 更新时比较version

监视命令 watch unwatch

```
watch money 
multi
decrby money 10
incrby out 10
exec # 执行之前，如果有另一个线程取修改了money，watch比较version失败，事务会自动取消/执行失败
```

如果事务的命令失败, unwatch一下, 再重新watch一下



# Jedis

导入

```
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>3.0.1</version>
</dependency>
```

使用

```
public static void main(String[] args) {
        //连接redis
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        System.out.println(jedis.ping());
        //Jedis所有的方法都是之前的redis命令！！！

        //验证密码
        jedis.auth("");
        //开启事务
        Transaction multi = jedis.multi();
        jedis.watch("");
        multi.exec();
    }
```



# springboot整合 自定义RedisTemplate

1. 导入

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

说明在springboot2.x之后, 原来使用jedis被替换为了lettuce

jedis: 采用直连, 多个线程操作的话,是不安全的, 如果要避免不安全,使用jedispool连接池 BIO

lettuce: 采用netty, 实例可以在多个线程中进行共享, 不存在线程不安全的情况

2. 书写配置

```
//1.Springboot 所有的配置类，都有一个自动配置类，RedisAutoConfiguration
//自动配置类都会绑定一个properties配置文件 RedisProperties
//2.@ConditionOnMissingBean(name="redisTemplate")
//如果没有这个名字的实例, 则会创建springboot默认的redistemplate对象
//3.配置redis
spring.redis.host=127.0.0.1
spring.redis.port=6379
```

3. 操作redis

```
@Resource
private RedisTemplate redisTemplate

test(){
	//opsForList
	//opsForSet
	//opsForHash
	//opsForZset
	//opsForGeo
	//opsForHyperLoglog
	redisTemplate.opsForValue()
	
}
```

4. 序列化配置 (编写自己的RedisTemplate)

```
//为什么要序列化: 当你需要通过媒介(网络)传输对象时, 对象不能直接传输, 需要序列化
//什么是序列化:
当你的pojo类去实现Serializable接口时, 当你去传输pojo对象时, 会把他进行序列化操作
//序列化操作有默认的jdk的序列化, 有json的序列化(开发一般使用json的序列化)
我们需要指定序列化方式
//小细节, 如果是jdk的序列化方式, keys * 在命令行是会有转义字符的!
```

自己定义的RedisTemplate

```java
@Bean
    public RedisTemplate<String, Object > myRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory);
        //序列化配置
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        //String 的序列化方式
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        //key 采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        //hash的key 采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        //value 采用jackon的序列化方式
        template.setValueSerializer(jackson2JsonRedisSerializer);
        //hash的value 采用jackon的序列化方式
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        return template;
    }
```

# Redis.conf配置详解

- 网络

  ```
  //服务器的redis, 主要改这三个公网ip, 不保护, 改端口
  bind 0.0.0.0 # 是绑定到本机的所有IP上
  protected-mode yes # 一般不保护
  port 6379
  ```

- 通用

  ```conf
  daemonize yes # 以守护进程的方式进行, 默认是no. 不yes的话, 一退出redis就关掉啦
  pidfile # 如果以后台的方式运行，需要指定一个进程文件
  loglevel notice
  logfile "" # 日志文件的位置
  databases 16 # 数据库的数量,默认16个
  always-show-logo yes # 启动是否显示logo
  ```

- 快照( 持久化用到的, 在规定时间内, 执行了多少次操作, 则会持久化到文件 )

  redis是内存数据库, 如果没有持久化, 那么数据断电就没

  ```
  # 如果900秒内, 如果至少有 1个key进行了修改, 我们即使进行持久化操作
  save 900 1
  stop-writes-on-bgsave-error yes # 持久化出错是否继续工作
  rdbcompression yes # 是否压缩rdb文件,需要消耗一些cpu资源
  rdbchecksum yes # 保存rdb文件的时候, 进行错误的检查校验
  dir ./ # rdb文件保存的目录
  ```

- REPLICATION 主从复制相关的

  ```
  ```

- SECURITY

  ```
  requirepass 
  # 通过命令设置
  config set requirepass ""
  # 通过命令,使用密码, 才能使用命令
  auth [password]
  ```

- CLIENTS

  ```
  maxclients 1000 # 设置能连接上redis的最大客户端的数量
  maxmemory <bytes> # 设置最大的内存容量
  maxmemory-policy noeviction # 内存到达上限之后的处理策略
  1、volatile-lru: 只对设置了过期时间的key进行LRU(默认值)
  2、allkeys-lru : 删除lru算法的key
  3、volatile-random: 随机删除即将过期key
  4、allkeys-random: 随机删除
  5、volatile-ttl : 删除即将过期的
  6、noeviction : 永不过期，返回错误
  ```

- APPEND ONLY

  ```
  appendonly no # 默认是不开启aof模式的, 默认使用rdb方式持久化,在大部分情况下rdb够用了
  appendfilename "" # aof文件名
  appendsync everysec # everysec每秒执行一次tong'bu| always每次修改就同步 | no操作系统自己同步数据,速度最快
  ```

  

# Redis持久化

# Redis发布订阅

# Redis主从复制

# Redis缓存穿透和学崩





# 关键词

定时删除, 惰性删除, 内存淘汰

布隆过滤器: 缓存穿透, 缓存击穿, 缓存雪崩 (过期时间均匀分布, 热点数据永不过期)

# Springboot中集成Redis

1. 修改application.yml配置文件

2. 配置基本参数 host port password

3. 定义自己的RedisTemplate, @Resource(name = "指定自己的bean名")

4. 使用RedisTemplate
