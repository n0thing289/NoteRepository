---
title: 微服务
date: 2024-05-08
---

## Mp

## Docker

快速构建, 运行, 管理应用的工具; 

对于单体项目, 部署方式也就是打包,部署,运行linux命令启动. 

但是现在对于微服务而言, 每个业务都是独立可打包部署的, 传统部署方式太麻烦了

### docker安装

>uname -r #通过 uname -r 命令查看你当前的内核版本
>
>Docker要求CentOS系统的内核版本高于3.10

1. 卸载旧版

   ```
    sudo yum remove docker \
                     docker-client \
                     docker-client-latest \
                     docker-common \
                     docker-latest \
                     docker-latest-logrotate \
                     docker-logrotate \
                     docker-engine
   ```

2. 配置docker的yum库

   安装yum工具

   ```bash
   sudo yum install -y yum-utils
   ```

   映射仓库地址

   ```
   ## 建立Docker仓库 (映射仓库地址)
   sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
   ```

3. 安装docker

   ```
   sudo yum install docker-ce docker-ce-cli containerd.io
   ```

4. 启动和校验

   启动docker

   ```
   sudo systemctl start docker
   //停止docker
   sudo systemctl stop docker
   //重启
   sudo systemctl restart docker
   //设置开机自启
   sudo systemctl enable docker
   //执行docker ps命令， 不报错说明安装启动成功
   docker ps
   ```

    测试是否安装正常

    ```
    sudo docker run hello-world
    ```

5. 配置镜像加速

   注册阿里云账号

   开通镜像服务

   配置镜像加速
   
   ```
   1. 安装／升级Docker客户端
   推荐安装1.10.0以上版本的Docker客户端，参考文档docker-ce
   
   2. 配置镜像加速器
   针对Docker客户端版本大于 1.10.0 的用户
   
   您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器
   
   sudo mkdir -p /etc/docker
   sudo tee /etc/docker/daemon.json <<-'EOF'
   {
     "registry-mirrors": ["https://gnsr8ejh.mirror.aliyuncs.com"]
   }
   EOF
   sudo systemctl daemon-reload
   sudo systemctl restart docker
   ```
   
   

### docker基础

为什么docker部署mysql, 在下载东西, 然后就可以跑起来了? 

- 和传统安装软件一样, 你先下载安装包然后安装, 最后生成了一堆磁盘文件, 就可以跑起来; 如果我直接把最后的磁盘文件全部下载好(绿色免安装版), 不就可以直接运行了
- 其次, 关于配置文件的问题, 如果我下载好后, 做了配置; 然后我换了机器, 我只需要把(磁盘文件+配置文件)(镜像)全部给你, 这样你也可以跑起来, 这个例子就简要说明了docker的基本原理

docker安装应用的时候, 会自动搜索镜像并使用`镜像`. 镜像=应用+运行环境+配置+系统函数库...; 当你运行镜像的时候会创建一个隔离的环境(联想VMware运行多个虚拟的系统!),称为`容器`

`镜像仓库`: 存储和管理镜像的平台, Docker官方维护了一个公共仓库: Docker Hub

`镜像`: 镜像名字是唯一的, 如果本地运行时没有这个镜像, 就回去镜像仓库寻找并下载

`容器`: 有独立的文件, 网络系统...来运行镜像; 容器只有必备的资源确保镜像运行

![image-20240509204856328](./微服务笔记/image-20240509204856328.png)![image-20240509210430764](./微服务笔记/image-20240509210430764.png)

#### 常见命令

![image-20240509211420366](./微服务笔记/image-20240509211420366.png)

从镜像仓库拉去镜像 docker pull

查看本地镜像 docker images

删除镜像 docker rmi

自定义镜像 docker build

将镜像打包成tar docker save

读取tar作为本地镜像 docker load -i jdk.tar

推送镜像至镜像仓库(可以是官方的镜像仓库/私服仓库) docker push

运行镜像 `docker run  -d -name "" -p "":"" -v "":"" --network "" image`  #注意这步是给镜像生成容器并运行

停止运行镜像 `docker stop 容器名`

启动已停止的镜像 `docker start 容器名`  #容器还在, 只不过是停止了

查看运行中/已停止的容器 `docker ps`

删除容器 `docker rm -f 容器名`

查看容器日志 `docker logs -f 容器名`

执行命令至容器内部 `docker exec [-it nginx bash]`

查看容器信息 `docker inspect 容器名`

命令帮助提示符 --help

![image-20240509211504035](./微服务笔记/image-20240509211504035.png)

查看容器命令的优化

```
vi ~/.bashrc
docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}\t{{.Names}}"
source ~/.bashrc
```



#### 数据卷

##### 案例引入

![image-20240509214246425](./微服务笔记/image-20240509214246425.png)

1. 先去找到html目录(容器内目录), 官方镜像的文档
2. docker run -v 数据卷:容器内目录

##### 什么是数据卷

![image-20240509214923621](./微服务笔记/image-20240509214923621.png)

- 是虚拟的目录, 逻辑目录
- linux版docker是在`/var/lib/docker/volumes`下
- 一旦创建了这个映射关系, docker会把容器内目录和宿主机目录进行双向数据绑定!

##### 怎么使用数据卷

![image-20240509215222819](./微服务笔记/image-20240509215222819.png)

##### 怎么去挂载数据卷到容器上

- ==在执行docker run命令时, 使用-v 数据卷:容器内目录 就可以完成数据卷挂载==
- 当创建容器时, 如果挂载数据卷且数据卷不存在, 则会自动创建数据卷

##### 挂载到任意你想要的目录下

![image-20240510092135061](./微服务笔记/image-20240510092135061.png)

- mysql采用的时`匿名卷`每次迁移数据, 目录又深又不好找
- ![image-20240510092314470](./微服务笔记/image-20240510092314470.png)

#### 自定义镜像

>自己开发了java应用，也要部署，也要在docker上使用；必须自己做一个镜像

镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程其实就是把上述文件打包的过程。

生成java镜像的步骤：

1. linux环境
2. jre
3. jar包
4. 启动脚本

生成镜像的结果,不是一个包,而是多个层的压缩包, 这些层构成了一个镜像; 当你制作镜像时, 出现重复的层, 就无需再次下载了

![image-20240510101058397](./微服务笔记/image-20240510101058397.png)

##### Dockerfile

> 描述镜像结构

写dockerfile

![image-20240510101219317](./微服务笔记/image-20240510101219317.png)

例如: 

```
#指定基础镜像
FROM ubuntu:16.04
# 配置环境变量，JDK的安装目录、容器内时区
ENV JAVA_DIR=/usr/local
# 拷贝jdk和java项目的包
COPY ./jdk8.tar.gz $JAVA_DIR/
COPY ./docker-demo.jar /tmp/app.jar
# 安装JDK
RUN cd $JAVA_DIR \ && tar -xf ./jdk8.tar.gz \ && mv ./jdk1.8.0_144 ./java8
#配置环境变量
ENV JAVA_HOME=$JAVA_DIR/java8
ENV PATH=$PATH:$JAVA HOME/bin
# 入口，java项目的启动命令
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

```
#指定基础镜像
FROM openjdk:11.0-jre-buster
#
COPY docker-demo.jar /app.jar
#
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

构建镜像

```
#-t 是给镜像起名
#. 代表当前目录下找dockerfile
docker build -t myImage:1.0 .
```

小结: 镜像的结构是怎样的, dockerfile是做什么的, 构建镜像的命令是社么

#### 容器网络

>解决容器之间通信的问题

docker有一个默认网桥(网卡), 它会分配每个容器ip地址, 但是存在ip地址变更的麻烦

所以自定义网络出现了: 加入自定义网络后, 通过容器名访问

![image-20240510111745900](./微服务笔记/image-20240510111745900.png)



### 项目部署

#### 部署java

![image-20240510121452923](./微服务笔记/image-20240510121452923.png)

```
docker build -t hmall .
docker run -d --name hm -p 8080:8080 --network heima hmall
```



#### 部署前端

![image-20240510121510869](./微服务笔记/image-20240510121510869.png)

```
docker run -d \
--name nginx
-p 18080:18080 \
-p 18081:18081 \
-v /root/nginx/html:/usr/share/nginx/html \
-v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \
--network heima \
nginx
```



#### Docker-Compose

>前两个项目部署需要自己去打包构建镜像, 以及各种中间件的部署,加入网络都是比较分散的!
>
>Docker Compose通过一个单独的docker-compose.yml 模板文件(YAML格式)来定义一组相关联的应用容器，帮助我们实现多个相互关联的Docker容器的快速部署。

![image-20240510152559823](./微服务笔记/image-20240510152559823.png)

对比理解docker-compose.yml文件![image-20240510152751999](./微服务笔记/image-20240510152751999.png)其实每一个service和一个docker run容器命令是很相似的!!!



使用DockerCompose

![image-20240510153754520](./微服务笔记/image-20240510153754520.png)还有最后面加 -d 后台运行 





### nginx和mysql容器内目录

nginx conf: /etc/nginx/nginx.conf

nginx html: /usr/share/nginx/html

mysql镜像的配置目录: /etc/mysql/conf.d 

mysql初始化脚本目录: /docker-entrypoint-initdb.d

mysql数据目录: /var/lib/mysql



## 单体项目和微服务的特征和区别

单体项目适合小型项目

![image-20240510175526184](./微服务笔记/image-20240510175526184.png)

微服务(拆出来n个单体项目)适合大型项目, 性能更好

![image-20240510180541357](./微服务笔记/image-20240510180541357.png)

微服务拆了之后, 出现的问题, 开发和运维的复杂度提升了, 可以通过微服务的架构来解决



## SpringCloud

课程介绍

![image-20240510170342211](./微服务笔记/image-20240510170342211.png)



SpringCloud 是集成了不仅有自己的组件以及集成很多家的组件

![image-20240510181125012](./微服务笔记/image-20240510181125012.png)

springcloud 是标准的制定者, 定义了大量的规范和接口

### 微服务拆分

微服务项目结构

- 独立project, 每一个微服务都是独立的文件夹, 都放在同一个文件夹上(大型项目比较合适, 增加管理负担)
- maven聚合, 每一个微服务都是一个module, 运行时独立分开的, 代码写在一起(适合中小型项目)

#### 什么时候拆分

- 创业型项目, 先快速开发单体项目, 后期再过度到微服务(后期拆分麻烦)
- 大型项目, 上来就只用微服务, 没有后续拆分的麻烦

#### 如何拆分

什么叫高内聚(目标)

- 当你日后改代码更新迭代的时候, 大部分是在这个微服务内部的, 而几乎不去动其他服务

什么叫低耦合(目标)

- 核心业务服务内部完成, 不要调用或依赖其他服务(除非负责/跨服务业务)

有哪些拆分方式(做法)

- 按照业务模块来拆分(纵向拆分)
- 抽取公共服务, 提高复用性(横向拆分)

#### 拆分后遇到的第一个问题(远程调用)

微服务拆分后，数据和服务都是隔离的。当你去使用购物车服务的时候，需要查询最新的商品信息。但是服务之间是不能直接访问对方的数据库的

使用RestTemplate发生http请求（远程调用）

```java
//1. exchange（）
ResponseEntity<List<ItemDTO>> response = restTemplate.exchange(
    "http://localhost:8081/items?ids={ids}",
    HttpMethod.GET,
    null,
    new ParameterizedTypeReference<List<ItemDTO>>() {},
    Map.of("ids", CollUtil.join(itemIds, ","))
);
//2. getStatusCode() is2xxSuccessful()
response.getStatusCode().is2xxSuccessful()
```

>@RequiredArgsConstructor给必要的字段(final)加构造函数
>
>泛型没有字节码, 但是对象里的泛型可以通过反射获得
>
>hutool的CollUtil.join(itemIds,",")和 org.apache.commons.lang3的StringUtils.join一样

### 服务治理

>之前使用restTemplate去做远程调用, 其实不太好用; 
>
>如果某个服务是一个集群, ip地址和端口都比较难确定, 以及不好分配请求给集群; (==不好确定被调用服务的地址==, ==如果被调用服务挂了如何感知?== ==多个实例,消费者该选择哪一个?== 等等使用中会出现的问题)

#### 注册中心原理

有天你(==服务调用者==)需要家政服务, 你不可能路上找一个大妈(==服务提供者==)给你干活, 应该直接去找家政公司(==注册中心==)!

![image-20240512211405351](./微服务笔记/image-20240512211405351.png)

1. 服务提供者注册服务信息到注册中心; 后续提供者需要对注册中心进行心跳续约

2. 服务调用者订阅某个服务的信息; 后续注册中心会推送变更给调用者

3. 服务调用者对服务挑选(负载均衡);

4. 服务调用者远程调用那个服务;

#### Nacos注册中心

>eruka、nacos都是注册中心的组件，都实现springcloud的规范(大差不差)

nacos镜像安装

```
docker run -d \
--name nacos \
--env-file ./nacos/custom.env \
-p 8848:8848 \
-p 9848:9848 \
-p 9849:9849 \
--restart=always \
nacos/nacos-server:v2.1.0-slim
```

nacos的访问地址: http://192.168.224.128:8848/nacos

用户名密码都是nacos

#### 服务注册

1. 引入依赖

   ```xml
   <!--nacos 服务注册发现-->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

2. 配置nacos地址

   ```yaml
   spring:
     application:
       name: item-service
     cloud:
       nacos: 
         server-addr: 192.168.224.128:8848
   ```

#### 服务发现

1. 引入依赖

   ```xml
   <!--nacos 服务注册发现-->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

2. 配置nacos地址

   ```yaml
   spring:
     application:
       name: item-service
     cloud:
       nacos: 
         server-addr: 192.168.224.128:8848
   ```

3. 服务发现

   ```
   //springCloud定义的规范接口,
   
   ```

   
