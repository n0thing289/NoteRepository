---
title: Lambda
tags: java8新特性
categories: java后端
date: 2024-04-10
---



## lambda表达式

- 是jdk8语法糖, 简化一些匿名内部类(接口?)的写法

- 核心原则: 可推到可省略

- 定义的格式

  ```
  (参数列表)->{代码}
  ```

- 什么情况下可以用lambda?
  - 函数式接口才可以，接口上有这个注解的@FunctionalInterface
  - 是一个接口的匿名内部类, 且只有一个抽象方法需要重写

>只有函数式接口才能用这种写法(函数式接口很好辨认，接口上有@FunctionalInterface注解的就是函数式接口)
>
>一个lambda表达式就是一个函数式接口的实例
>
>什么是函数式接口，只有一个抽象方法的接口

- 使用lambda时一些省略规则
  -  参数的类型可以省略
  - 方法体只有一句代码时，大括号、return和唯一一句代码的分号可以省略
  - 方法只有一个参数时小括号可以省略
  - 以上这些规则记不住 记得按快捷键 alt+enter



## Stream流

Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对==集合或数组==进行链状流式的操作。可以更方便的让我们
对集合或数组操作。



- 案例准备

  Author.java

  ```java
  @Data
  @NoArgsConstructor
  @AllArgsConstructor
  @EqualsAndHashCode
  public class Author {
      private Long id;
      private String name;
      private Integer age;
      private String intro;
      private List<Book> books;
  }
  ```

  Books.java

  ```java
  @Data
  @NoArgsConstructor
  @AllArgsConstructor
  @EqualsAndHashCode
  public class Book {
      private Long id;
      private String name;
      private String  category;
      private Integer score;
      private String intro;
  }
  ```

  StreamDemo1.java

  ```java
  public static List<Author> listAuthors(){
      Author author = new Author(1L, "蒙多", 33, "一个从菜刀中明悟哲理的祖安人", null);
      Author author2 = new Author(2L, "亚拉索", 15, "狂风也追逐不上他的思考速度", null);
      Author author3 = new Author(3L, "易", 14, "是这个世界在限制他的思维", null);
      Author author4 = new Author(3L, "易", 14, "是这个世界在限制他的思维", null);
  
      List<Book> books1 = new ArrayList<>();
      List<Book> books2 = new ArrayList<>();
      List<Book> books3 = new ArrayList<>();
  
      books1.add(new Book(1L, "刀的两侧是光明与黑暗", "哲学,爱情", 88, "用一把刀划分了爱恨"));
      books1.add(new Book(2L, "一个人不能死在同一把刀下", "个人成长,爱情", 99, "讲述如何从失败中明悟真理"));
      books2.add(new Book(3L, "那风吹不到的地方", "哲学", 85, "带你用思维去领略世界的尽头"));
      books2.add(new Book(3L, "那风吹不到的地方", "哲学", 85, "带你用思维去领略世界的尽头"));
      books2.add(new Book(4L, "吹或不吹", "爱情,个人传记", 56, "一个哲学家的恋爱观注定很难把他所在的时代理解"));
      books3.add(new Book(5L, "你的剑就是我的剑", "爱情", 56, "无法想象一个武者能对他的伴侣这么的宽容"));
      books3.add(new Book(6L, "风与剑", "个人传记", 100, "两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢 ? "));
      books3.add(new Book(6L, "风与剑", "个人传记", 100, "两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢?"));
  
      author.setBooks(books1);
      author2.setBooks(books2);
      author3.setBooks(books3);
      author4.setBooks(books3);
      List<Author> authorList = new ArrayList<>(Arrays.asList(author, author2, author3, author4));
      return authorList;
  }
  ```

  

- 案例一

  ![image-20240411203445693](./函数式编程/image-20240411203445693.png)

### 1. 创建流对象 ctrl alt m

单列集合( List 和 Set ): ==集合对象.stream()==

数组: ==Arrays.stream()== 或 ==Stream.of(array)==

双列集合(Map, 需要先转换成Set): ==map对象.entrySet().stream()==

### 2. 中间操作

filter

```
filter(()->{return true})
```

map

```
可以把流中的内容转换或者计算！（映射） map前 map后 注意流映射后的剩余的东西
```

distinct

```
需要重写equals和hashCode方法, 不然底层使用Object的equals, 不能对属性重复做到去重
```

sorted

```
如果调用空参的sorted方法，需要流中的元素实现comparable
```

limited

```
设置流的最大长度， 超出的部分将被抛弃
```

skip

```
跳过第x个元素，从1开始做为第一个元素
```

flatMap

```
flatMap可以把list扁平化，拆出里面的元素到流中（一个对象转换成多个对象）
```

### 3. 终结操作  总结操作要有, 流才会动起来

foreach

```
对流中的元素进行遍历
```

count

```
获取当前流中元素的个数
```

max&min

```
获取流中的元素的最值， 参数提供两个对象, 返回的Optional对象需要.get()获取最值
```

collect

```
将流转换成单列集合, 数组, Map 
转换成List: collect的参数, 使用工具类Collectors.toList()
转换成Set: Collectors.toSet()
转换成Map: Collectors.toMap(()->{return 如何转换key}, ()->{return 如何转换value})
```

------

查找和匹配

anyMatch

```
参数提供一个判断条件, 返回布尔值
anyMatch((obj)->{return obj>19}) 
```

allMatch

```
判断流中元素是否都符合判断条件, 都符合返回true, 反之false
```

noneMatch

```
判断流中元素是否都不符合判断条件
```

findAny

```
获取流中符合判断条件的元素, 返回Optional对象
配合filter一起使用, 先filter
```

findFirst

```
获取流中第一个元素
配合filter一起使用, 先filter
```

reduce归并 --和Js ES6 的reduce一样

```java
//将流归并成值, 底层有累加器, 第一个值和第二个值运算, 然后结构作为下一次的初始值和第三个值运算...
//可以用来求和, 求最大值...
//如果不提供初始化值, reduce((result, element)->{}) 初始化值就是流中第一个元素
reduce(identity, (result, element)->{})

```

------

小节

- 惰性求值 (如果没有终结操作，没有中间操作是不会得到执行的)
- 流是一次性的(一旦一个流对象经过一个终结操作后。这个流就不能再被使用)
- 不会影响原数据(我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的)



## Optional

>避免出现空指针异常
>
>```
>if(){
>
>}
>```
>

1. 创建optional对象

   ```java
   /**
   将数据包装成Optional对象, 对象存到了value属性上
   无论传入的参数是否为null都不会出现问题
   */
   Optional.ofNullable(obj) //底层使用empty() 和of(value), 这两个是手动判断封装
   ```

   mybatis从3.5版本开始也已经支持optional了, 直接把dao方法返回Optional类型即可,mybatis会自己把数据封装成Optional对象返回

2. 使用optional对象

   ```java
   optional对象.ifPresent(value->{}) //如果value存在, 就执行lambda函数,把value作为参数
   ```

   ------

   **安全获取值**

   >不推荐get方法直接获取值

   orElse

   ```java
   //获取数据并且设置数据为空时的默认值. 如果数据不为空就能获取到该数据. 如果为空则根据你传入的参数来作为默认值返回
   optional对象.orElse(0.0)
   ```

   orElseGet

   ```java
   //获取数据并且设置数据为空时的默认值. 如果数据不为空就能获取到该数据. 如果为空则根据你传入的参数来创建对象作为默认值返回
   optional对象.orElseGet(()->{return '默认值';})
   ```

   orElseThrow

   ```java
   //获取数据,如果数据不为空就能获取到该值. 如果数据为空就会排除你传入的参数的异常
   optional对象.orElseThrow(()->{return new RuntimeException('异常');})
   ```
   
   ------

   **过滤**

   ```java
   //返回一个新的optional对象, 如果判断条件不成立, 新对象的value是null
   optional对象.filter((author)->{return author.getAge()>18;})
   ```
   
   ------
   
   **判断**
   
   ```java
   /**我们可以使用isPresent方法进行是否存在数据的判断。
   如果为空返回值为false,如果不为空，返回值为true。
   但是这种方式并不能体现Optional的好处，更推荐使用ifPresent方法。
   */
   optional对象.isPresent()
   ```
   
   ------
   
   **数据转换**
   
   ```java
   //返回新的Optional对象, map将旧value转换成新value
   optional对象.map(value->author.getBooks())
   ```



## 函数式接口

>只有一个抽象方法的接口我们称之为函数接口。
>JDK的函数式接口都加上了@Functionallnterface 注解进行标识但是无论是否加上该注解只要接口中只有一个抽象法，都是函数式接口。
>
>也可以自己定义函数式接口

### 常见的函数式接口

- Consumer
- Function

- Predicate --判断
- Supplier



## 方法引用

>进一步简化lambda表达式写法

### 基本格式

`类名或者对象名::方法名`

### 推荐使用方式

​	idea提示把你的lambda表达式(==一行代码, 且是方法调用==)报黄, 你就alt + enter, method reference

### 语法规则

#### 1. 引用类的静态方法

格式

```
类名::方法名
```

使用前提

​	如果我们在重写方法的时候，方法体中==只有一行代码==，并且这行代码是调用了==某个类的静态方法==，并且我们把要重写的==抽象方法中所有的参数都按照顺序传入了这个静态方法中==，这个时候我们就可以引用类的静态方法。

#### 2. 引用对象的实例方法

格式

```
对象名::方法名
```

使用前提

​	如果我们在重写方法的时候，方法体中==只有一行代码==，并且这行代码是==调用了某个对象的成员方法==，并且我们把要重写的==抽象方法中所有的参数都按照顺序传入了这个成员方法中==，这个时候我们就可以引用对象的实例方法

#### 3. 引用类的实例方法

格式

```
类名::方法名
```

使用前提

​	如果我们在重写方法的时候，方法体中==只有一行代码==，并且这行代码是==调用了第一个参数的成员方法==，并且我们把要重写的==抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中==，这个时候我们就可以引用类的实例方法。

#### 4. 构造器引用

格式

```
类名::new
```

使用前提

​	如果我们在重写方法的时候，方法体中==只有一行代码==，并且这行代码是==调用了某个类的构造方法==，并且我们把要重写的==抽象方法中剩余的所有的参数都按照顺序传入了这个构造方法中==，这个时候我们就可以引用构造器方法。

## Stream基本数据类型优化

map映射中, 涉及流中元素, 装箱拆箱, 浪费资源且数据量大会耗时; 

所以涉及基本数据类型计算可以使用针对基本数据类型优化的方法

map instead of `mapTolnt,mapToLong,mapToDouble,flatMapTolnt,flatMapToDouble等`

## 并行流

​	当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。



使用并行流

```java
stream对象.parallel() //返回stream对象, 可以继续.
//可以使用之后.peek()查看流中工作的线程
    
parallelStream()
```

[拥抱 Java 8 并行流：执行速度飞起 ！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/339472446)

>**前言**
>
>在 Java7 之前，如果想要并行处理一个集合，我们需要以下几步 1. 手动分成几部分 2. 为每部分创建线程 3. 在适当的时候合并。并且还需要关注多个线程之间共享变量的修改问题。而 Java8 为我们提供了并行流，可以一键开启并行模式。是不是很酷呢？让我们来看看吧
>
>**什么是并行流：** 并行流就是将一个流的内容分成多个数据块，并用不同的线程分别处理每个不同数据块的流。



如果希望并行流之后的顺序是按照原来Stream的数据顺序，那可以调用forEachOrdered()

## Idea快捷键

ctrl alt m 提取为方法
